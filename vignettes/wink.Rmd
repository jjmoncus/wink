---
title: "wink"
author: "J.J. Moncus"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{wink}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
resource_files:
  - doc/my_survey_results.xlsx
---

```{r, include = FALSE}
library(knitr)
library(kableExtra)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "asis"
)

# # write tables for data frames
# knit_print.data.frame = function(x, ...) {
#     res = paste(c("", "", kable(x, output = FALSE) %>%
#                     kable_styling(
#                       font_size = 10,
#                       full_width = FALSE
#                     )), collapse = "\n")
#     asis_output(res)
# }
# # register the method
# registerS3method("knit_print", "data.frame", knit_print.data.frame)
# # after you define and register the above method, data frames will be printed
# # as tables in knitr, which is different with the default print() behavior
library(wink)

# 1. Get the path to the original file in the source package structure
# original_path <- system.file("extdata", "my_survey_results.xlsx", package = "wink")

# 2. Define the *relative name* that the link should use
# results_file_name <- "my_survey_results.xlsx"

# 3. Copy the file to the current working directory (the build directory)
# This ensures the file is copied alongside the final HTML output.
# if (file.exists(original_path)) {
#   file.copy(original_path, results_file_name, overwrite = TRUE)
# }

# 4. Define the **markdown link** in a variable for easier use later.
# We use the relative file name as the URL.
# download_link <- paste0("[look like this](", results_file_name, ")")
download_link <- paste0("[look like this](my_survey_results.xlsx)")

```


The `wink` package provides functions for generating banners of survey estimates, complete with significance testing and exportable to Excel

The goal is to make Excel outputs that `r download_link`.

(^This link may only work when viewing this vignette from inside RStudio - apologies, hopefully I can resolve this soon!)

You'll principally use two main functions:

- `banner()`: Generates statistically-tested crosstabs against a common target variable and combines them into one wide "banner" table.

- `write_banners()`: Exports banners to a formatted Excel workbook.

A typical workflow will be to generate lists of banners using `banner()` and then export them with `write_banners()`.

The workhorse underneath `banner()` is `crosstab()`, which generates the percentages for a single crosstab, and which most users will not need to use. It is the guts for how the rest of the package works and is exposed just for convenience. See `crosstab()`'s documentation for the specifics.

# Setup and Data

You can install the most up-to-date version of the package via the github repo.

``` {r}
#| eval: false
pak::pak("jjmoncus/wink")
```

Or if you want to make sure you build vignettes:

``` {r}
#| eval: false
devtools::install_github("jjmoncus/wink",
                         build_vignettes = TRUE,
                         force = TRUE)
```



For this example, we'll use the synthetic `food` dataset that comes with the package. It contains `r nrow(food)` fictional survey responses, including demographics and respondents' attitudes about various foods.

``` {r}
#| results: "markup"
head(food, n = 5)
```


# 1. `banner()`: Generating crosstabs

## Percentages of `var`, split by `bys`

`banner()` generates a table of survey estimates for one variable (`var`) broken down by others (`bys`) and performs column-to-column significance testing (represented by letter rows). If a letter appears underneath a given cell, then the given survey estimate is statistically significantly different (at 95% confidence) from the corresponding column's cell (see below for an example).

A "Total" column is included in the front, with percentages across `var` for the full sample.

Unweighted n-sizes (n), design effects (deff), and margins of sampling error (moe) for each group are included at the bottom.

Below is a banner for a question about eating pescetarian (`pescetarian`), by age (`age`). The default `print()` method renders the output using `gt`, which tries to mimic how the Excel output would look when exported.

You would read the banner like this: among 18- to 35-year-old respondents, 14% responded "Low" when asked about their likelihood to eat pescetarian - and this is significantly different from the 9% of those 65-years-old and up who also said "Low." However, it is _not_ significantly different from the 12% of those 36 to 49 and those 50 to 64 who said the same.

``` {r}
#| warning: false
banner(
  data = food,
  var = "pescetarian",
  bys = "age"
)
```

As you add more `bys`, each new crosstab is concatenated to the next, and the table gets wider (hover over it and scroll to the right).


``` {r}
#| warning: false
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean")
)
```

(Note: If two or more `bys` share factor levels, then you might end up with columns that share a name, in which case they get renamed according to default `tibble()` rules. We might address this later).

## Metadata

Metadata about each crosstab in the banner is stored underneath as attributes. Some attributes let you know what was called in order to generate the table (`var`, `by`, `min_group_n`), while others are useful for writing banners to Excel outputs (`col_dividers`, `too_low_n`). The typical user won't need to see this, but it's there in case you need to check how any banners were created after the fact.


``` {r}
#| warning: false
#| results: "markup"
x <- banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean")
)

attributes(x)
```


## Weighting

Estimates are by default unweighted, but specifying `weight` generates weighted estimates.

``` {r}
# for example, here's add an arbitrary weight variable
food <- food %>%
  dplyr::mutate(weight_1 = runif(nrow(food), 0, 3)) # randomly give everyone a weight between 0 and 3

banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  weight = "weight_1"
)

```


## Rounding

`banner()` automatically rounds to whole percentages, but you can specify using `digits`.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  digits = 2
)
```

## Flagging too-low n-sizes

`min_group_n` allows you to specify what threshold of an n-size is considered too low. Estimates are still generated for any group that doesn't meet the threshold, but the corresponding n-size cell is colored red.

``` {r}

banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  digits = 2,
  min_group_n = 500 # setting `min_group_n` very high will naturally flag lots of groups
)
```


## Adding Net Categories

You can define NET (summary) categories using `var_nets`, which accepts a list of name-value pairs. Each NET category is inserted into the table right above the first level contributing to it.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  digits = 2,
  var_nets = list(
    "Low"  = c("Very Low", "Low"),
    "High" = c("High", "Very High")
    )
  )
```


You can also specify `var_nets` with just level numbers, instead of writing out the level text (this can be convenient when response options are long).

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  digits = 2,
  var_nets = list(
    "Low"  = 1:2,
    "High" = 4:5
    )
  )
```

`var_nets` doesn't have to be named. If you just provide the groups, `banner()` creates suitable names for you.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  digits = 2,
  var_nets = list(1:2, 4:5)
  )
```


## Excluding columns or rows

You may want to leave out some columns of `bys` or rows of `var` that aren't of interest. Supply a regular expression to `exclude_var` or `exclude_bys` to remove any columns/rows that match, without disrupting significance testing. Both are `NULL` by default (i.e. not removing anything).

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  exclude_var = "Moderate"
  )
```

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  exclude_bys = "DK/Refused" # providing one pattern recycles across all `bys`
  )
```

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  exclude_bys = c("65+", "DK/Refused", "Other|DK/Refused", "DK/Refused", "DK/Refused") # Otherwise, add as many patterns as there are `bys`
  )
```


```{r}
#| eval: false

banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  exclude_bys = c("65+", "DK/Refused") # adding fewer than `length(bys)` gives you an error
  )
```


## Removing respondents

We've set `na.rm = TRUE` by default, meaning if `var` contains any missing values, they are excluded from the denominator of survey estimates. `na.rm = FALSE` includes them and would report a "(Missing)" row for these new empty respondents.


``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("age", "income", "gender", "region", "party_lean"),
  na.rm = FALSE
  )
```


# 3. `write_banners()`: Exporting to Excel

`write_banners()` takes banners from `banner()` and exports them to a single, formatted Excel file. It separates banner groups with borders, adds merged-cell subheads over each group of by-columns, and creates a hyperlinked Table of Contents.

Any by-groups with `n` less than `min_group_n` will be highlighted in red, and there will be a message just below the table specifying what `min_group_n` value was used for comparisons.

We also message whether `na.rm` was `TRUE` or `FALSE`, and how many were removed from `var` if so.

The typical workflow would be to write a list of banners using `purrr::map()`

``` {r}
#| warning: false
#| message: false

banners <- c("pescetarian", "veggie", "vegan") %>%
  purrr::set_names() %>% # name the vector after itself, not required for `write_banners` but maybe convenient for you later
  purrr::map(function(x) {
    
    banner(
      data = food, 
      var = x,
      bys = c("age", "gender", "income", "region", "party_lean")
      )
  })

write_banners(banners, file = "my_survey_results.xlsx")

```


You can also export a single banner (i.e. it doesn't need to be wrapped in a list).

``` {r}
#| warning: false
#| message: false

x <- banner(food, "pescetarian", bys = c("age", "gender", "income", "region", "party_lean"))

x %>% write_banners(file = "single_banner.xlsx")

```

By default, you will overwrite any files with the same name (i.e. `overwrite = TRUE`). If you flip `overwrite = FALSE`, you will throw an error if the file already exists.

``` {r}
#| warning: false
#| message: false
#| eval: false

# rexport the above would throw an error if `overwrite = FALSE`
x %>% write_banners(file = "single_banner.xlsx", overwrite = FALSE)

```


Numeric rows are saved as number values, and character rows are saved as text. `write_banners()` by default formats the percentage rows as integers, and the "deff + mose" rows with two decimal places. If you'd prefer them presented as raw, full-decimal-place values, use `format_numbers = FALSE`.

``` {r}
#| warning: false
#| message: false

x %>% write_banners(file = "no_formatting.xlsx", format_numbers = FALSE)

```

