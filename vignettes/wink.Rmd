---
title: "wink"
author: "J.J. Moncus"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{wink}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# write tables for data frames
knit_print.data.frame = function(x, ...) {
    res = paste(c("", "", kable(x, output = FALSE)), collapse = "\n")
    asis_output(res)
}
# register the method
registerS3method("knit_print", "data.frame", knit_print.data.frame)
# after you define and register the above method, data frames will be printed
# as tables in knitr, which is different with the default print() behavior
library(wink)

# 1. Get the path to the original file in the source package structure
original_path <- system.file("extdata", "my_survey_results.xlsx", package = "wink")

# 2. Define the *relative name* that the link should use
results_file_name <- "my_survey_results.xlsx"

# 3. Copy the file to the current working directory (the build directory)
# This ensures the file is copied alongside the final HTML output.
if (file.exists(original_path)) {
  file.copy(original_path, results_file_name, overwrite = TRUE)
}

# 4. Define the **markdown link** in a variable for easier use later.
# We use the relative file name as the URL.
download_link <- paste0("[look like this](", results_file_name, ")")

```


The `wink` package provides functions for generating publication-ready survey tables, complete with significance testing and report-ready export features.

The goal is to make Excel outputs that `r download_link`.

The two main functions demonstrated here are:

- `banner()`: Generates multiple, statistically tested crosstab tables against a common target variable and combines them into one wide "banner" table.

- `write_banners()`: Exports banner tables to a formatted Excel workbook.

A typical workflow will be to generate lists of tables using `banner()` and then export them with `write_banners()`.

The workhorse underneath `banner()` is `crosstab()`, which generates the percentages for a single crosstab, and which most user will not need to use. It is meant to be the guts for how the rest of the package works and is exposed just for convenience. See `crosstab()`'s documentation for the specifics.

# Setup and Data

You can install the most up-to-date version of the package via the github repo.

``` {r}
#| eval: false
pak::pak("jjmoncus/wink")
```

Or if you want to make sure you build vignettes:

``` {r}
#| eval: false
devtools::install_github("jjmoncus/wink",
                         build_vignettes = TRUE,
                         force = TRUE)
```



For this example, we'll use the synthetic `food` dataset that comes with the package.

``` {r}
# In a real session, the data loads automatically when your package is attached.
head(food, n = 5)
```

The `food` dataset contains `r nrow(food)` fictional survey responses, including demographics and food attitude ratings.

# 1. `banner()`: Generating crosstabs

## Percentages of `var`, split by `bys`

The `banner()` function generates a percentage table for one variable (`var`) broken down others (`bys`) and performs column-to-column statistical testing (represented by letter rows).

unweighted N's, Design Effects (DEFF), and Margins of Sampling Error (MOSE) for each group are included at the bottom..

Here's a banner for the likelihood of being pescetarian (`pescetarian`), by taste for meat (`rating_meat`).

``` {r}
#| warning: false
banner(
  data = food,
  var = "pescetarian",
  bys = "rating_meat"
)
```


By default, `banner()`, includes a Total column in the front, with percentages across `var` for the full sample (i.e. split by nothing.)

As you add more `bys`, each new crosstab is concatenated to the next.

If two or more `bys` share factor levels, then we would naturally end up with columns with the same name, so these are renamed according to `tibble()` rules (might come back to this later).


``` {r}
#| warning: false
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg")
)
```


Metadata about each crosstab of the banner is stored underneath as attributes. Some attributes let you know what was called in order to generate the table (`var`, `by`, `min_group_n`), while others are useful for writing banners to Excel outputs (`col_dividers`, `too_low_n`).


``` {r}
#| warning: false
x <- banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg")
)

attributes(x)
```



## Weighting

Specifying `weight` generates weighted estimates.

Unweighted estimates will naturally have design effects equal to 1, whereas weighted estimates will have unique `deff` values for each group.

``` {r}
# for example, here's add an arbitrary weight variable
food <- food %>%
  dplyr::mutate(weight_1 = runif(nrow(food), 0, 3)) # randomly give everyone a weight between 0 and 3


banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  weight = "weight_1"
)

```



## Rounding

`banner()` automatically rounds to whole percentages, but you can specify using `digits`.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  digits = 2
)
```

## Adding Net Categories

You can define NET (summary) categories using the `var_nets` argument, which takes a named list of character vectors. Each NET category is inserted into the table right above the first level contributing to it.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  var_nets = list(
    "Low"  = c("Very Low", "Low"),
    "High" = c("High", "Very High")
    )
  )

```


You can also specify `var_nets` with levels numbers.

``` {r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  var_nets = list(
    "Low"  = c(1:2),
    "High" = c(4:5)
    )
  )

```

## Excluding columns or rows

You may want to selectively leave out columns of `bys` or rows of `var` that aren't of interest. Supply a regex to `exclude_var` or `exclude_bys` to remove any columns/rows that match, without disrupting significance testing. Both are NULL by default (i.e. removing nothing).

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  exclude_var = "Moderate"
  )
```

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  exclude_bys = "equal" # providing one pattern recycles across all bys
  )
```

```{r}
banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  exclude_bys = c("Very much dislike", "equally", "Very much like") # Otherwise, add as many patterns as there are `bys`
  )
```


```{r}
#| eval: false

banner(
  data = food,
  var = "pescetarian",
  bys = c("rating_meat", "rating_sushi", "rating_veg"),
  exclude_bys = c("Very much dislike", "Very much like") # adding fewer than `length(bys)` gives you an error
  )
```


# 3. `write_banners()`: Exporting to Excel

`write_banners()` takes a list of banners from `banner()` and exports them to a single, formatted Excel file. It separates banner groups with borders, adds merged-cell subheads over each group of by-columns, and creates a hyperlinked Table of Contents.

Any by-groups with n less than `min_group_n` will be highlighted in red, and there will be a message just below the table specifying what `min_group_n` value was used for comparisons.

The typical workflow would be to write a list of banners using `purrr::map()`

``` {r}
#| warning: false
#| message: false

banners <- c("pescetarian", "veggie", "vegan") %>%
  purrr::set_names() %>% # name the vector after itself, not required for `write_banners` but maybe convenient for you later
  purrr::map(function(x) {
    
    banner(
      data = food, 
      var = x,
      bys = paste0("rating_", c("meat", "pizza", "sushi", "veg")))
  })

write_banners(banners = banners, file = "my_survey_results.xlsx", overwrite = TRUE)

```


You can also write a single banner, if you so choose (i.e. it doesn't need to be preemptively wrapped in a list).

``` {r}
#| warning: false
#| message: false

banner(food, "pescetarian", bys = paste0("rating_", c("meat", "pizza", "sushi", "veg"))) %>%
  write_banners(file = "single_banner.xlsx", overwrite = TRUE)

```


